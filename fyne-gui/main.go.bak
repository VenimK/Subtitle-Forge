package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
	
	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/widget"
)

// TrackItem represents a subtitle track with UI elements
type TrackItem struct {
	Num        int
	Lang       string
	Codec      string
	Name       string
	State      string
	Check      *widget.Check
	Status     *widget.Label
	ConvertOCR *widget.Check // Option to convert PGS to SRT using OCR
}

func main() {
	trackList := container.NewVBox()
	a := app.NewWithID("com.gmm.mkvsubsextract")
	w := a.NewWindow("GMM MKV Subtitles Extract (Fyne)")
	w.Resize(fyne.NewSize(520, 340))

	selectedFile := widget.NewLabel("No MKV file selected.")
	selectedDir := widget.NewLabel("No output directory selected.")
	result := widget.NewMultiLineEntry()
	result.SetPlaceHolder("Extraction results will appear here.")

	progress := widget.NewProgressBar()
	progress.Min = 0
	progress.Max = 1
	progress.SetValue(0)

	currentTrackLabel := widget.NewLabel("")
	trackItems := []*TrackItem{}

	var mkvPath string
	var outDir string


	fileBtn := widget.NewButton("Select MKV File", func() {
		dialog.ShowFileOpen(func(reader fyne.URIReadCloser, err error) {
			if err == nil && reader != nil {
				mkvPath = reader.URI().Path()
				selectedFile.SetText("Selected: " + mkvPath)
			}
		}, w)
	})

dirBtn := widget.NewButton("Select Output Directory", func() {
	dialog.ShowFolderOpen(func(list fyne.ListableURI, err error) {
		if err == nil && list != nil {
			outDir = list.Path()
			selectedDir.SetText("Output: " + outDir)
		}
	}, w)
})

// Button to load and display tracks
loadTracksBtn := widget.NewButton("Load Subtitle Tracks", func() {
	if mkvPath == "" || outDir == "" {
		dialog.ShowError(fmt.Errorf("Please select both MKV file and output directory."), w)
		return
	}
	result.SetText("Loading subtitle tracks...")
	progress.SetValue(0)
	progress.Max = 1
	currentTrackLabel.SetText("")

	// Clear any previous tracks
	trackItems = nil

	// Parse mkvmerge -J to get subtitle tracks
	cmdInfo := exec.Command("mkvmerge", "-J", mkvPath)
	infoOut, err := cmdInfo.Output()
	trackItems = nil
	if err == nil {
		var info struct {
			Tracks []struct {
				Id     int    `json:"id"`
				Type   string `json:"type"`
				Codec  string `json:"codec"`
				Props  struct {
					Language  string `json:"language"`
					TrackName string `json:"track_name"`
				} `json:"properties"`
			} `json:"tracks"`
		}
		if json.Unmarshal(infoOut, &info) == nil {
			for _, t := range info.Tracks {
				if t.Type == "subtitles" {
					item := &TrackItem{
						Num:    t.Id,
						Lang:   t.Props.Language,
						Codec:  t.Codec,
						Name:   t.Props.TrackName,
						State:  "Pending",
						Check:  widget.NewCheck("", nil),
						Status: widget.NewLabel("[ ] Pending"),
						ConvertOCR: widget.NewCheck("", nil),
					}
					
					// Default: none selected
					item.Check.SetChecked(false)
					
					// Only show OCR option for PGS subtitles
					if t.Codec == "hdmv_pgs_subtitle" || t.Codec == "HDMV PGS" {
						item.ConvertOCR.SetChecked(false)
					} else {
						// Hide OCR option for non-PGS subtitles
						item.ConvertOCR = nil
					}
					
					trackItems = append(trackItems, item)
				}
			}
		}
	}
	if len(trackItems) == 0 {
		// fallback: 1 dummy track
		item := &TrackItem{Num: 0, Lang: "?", Codec: "?", Name: "", State: "Pending", Check: widget.NewCheck("", nil), Status: widget.NewLabel("[ ] Pending")}
		item.Check.SetChecked(false)
		trackItems = append(trackItems, item)
	}
	progress.Max = float64(len(trackItems))
	progress.SetValue(0)
	for _, t := range trackItems {
		t.State = "Pending"
		t.Status.SetText("[ ] Pending")
	}

	// update the UI list
	trackList.Objects = nil
	for _, t := range trackItems {
		trackInfo := widget.NewLabel(fmt.Sprintf("Track %d: %s (%s) %s", t.Num, t.Lang, t.Codec, t.Name))
		
		if t.ConvertOCR != nil {
			// For PGS subtitles, show OCR option
			ocrLabel := widget.NewLabel("Convert to SRT")
			row := container.NewHBox(t.Check, t.Status, trackInfo, t.ConvertOCR, ocrLabel)
			trackList.Add(row)
		} else {
			// For other subtitle formats
			row := container.NewHBox(t.Check, t.Status, trackInfo)
			trackList.Add(row)
		}
	}
	trackList.Refresh()

	result.SetText("Tracks loaded. Select the tracks you want to extract, then click 'Start Extraction'")
})

// Button to start extraction of selected tracks
	startExtractBtn := widget.NewButton("Start Extraction", func() {
		if mkvPath == "" || outDir == "" {
			dialog.ShowError(fmt.Errorf("Please select both MKV file and output directory."), w)
			return
		}
		
		go func() {
			selected := []*TrackItem{}
			for _, t := range trackItems {
				if t.Check.Checked {
					selected = append(selected, t)
				}
			}
			if len(selected) == 0 {
				// Thread-safe UI update
				fyne.CurrentApp().SendNotification(&fyne.Notification{
					Title:   "No Tracks",
					Content: "No tracks selected.",
				})
				return
			}
			
			// Set up progress bar
			fyne.Do(func() {
				result.SetText("Extracting selected tracks...")
				progress.Max = float64(len(selected))
				progress.SetValue(0)
			})
			
			tracksDone := 0
			var output []byte
			var err error
			
			for i, t := range selected {
				// Update UI on main thread
				fyne.Do(func() {
					currentTrackLabel.SetText(fmt.Sprintf("Extracting track %d of %d: %s (%s) %s", i+1, len(selected), t.Lang, t.Codec, t.Name))
				})
				
				// Extract the subtitle track
				var outFile string
				
				// Get base filename without extension
				mkvBaseName := filepath.Base(mkvPath)
				mkvBaseName = strings.TrimSuffix(mkvBaseName, filepath.Ext(mkvBaseName))
				
				// Check if this is a PGS track with OCR conversion requested
				if t.ConvertOCR != nil && t.ConvertOCR.Checked && (t.Codec == "hdmv_pgs_subtitle" || t.Codec == "HDMV PGS") {
					// First extract as PGS
					fyne.Do(func() {
						result.SetText(result.Text + "\n\n[DEBUG] Starting PGS extraction process")
					})
					tempPgsFile := fmt.Sprintf("%s.track%d_%s.sup", mkvBaseName, t.Num, t.Lang)
					outFile = fmt.Sprintf("%s.track%d_%s.srt", mkvBaseName, t.Num, t.Lang) // Final output will be SRT
					
					// Get absolute paths for extraction
					absPgsPath := filepath.Join(outDir, tempPgsFile)
					
					// Debug output
					fyne.Do(func() {
						currentTrackLabel.SetText(fmt.Sprintf("Extracting PGS track %d...", t.Num))
						result.SetText(result.Text + "\n\n=== PGS Extraction ===\n")
						result.SetText(result.Text + fmt.Sprintf("Track: %d (%s)\n", t.Num, t.Lang))
						result.SetText(result.Text + fmt.Sprintf("Output directory: %s\n", outDir))
						result.SetText(result.Text + fmt.Sprintf("PGS file: %s\n", tempPgsFile))
						result.SetText(result.Text + fmt.Sprintf("Absolute path: %s\n", absPgsPath))
					})
					
					// Extract PGS first - use full command for debugging
					cmdStr := fmt.Sprintf("mkvextract tracks \"%s\" %d:\"%s\"", mkvPath, t.Num, tempPgsFile)
					fyne.Do(func() {
						result.SetText(result.Text + "\nRunning: " + cmdStr)
					})
					
					// Create the command with proper arguments
					cmd := exec.Command("mkvextract", "tracks", mkvPath, fmt.Sprintf("%d:%s", t.Num, tempPgsFile))
					cmd.Dir = outDir
					
					// Run the command and capture output
					output, err = cmd.CombinedOutput()
					
					// Debug output - show command result
					fyne.Do(func() {
						result.SetText(result.Text + "\nCommand output: " + string(output))
						if err != nil {
							result.SetText(result.Text + "\nError: " + err.Error())
						}
					})
					
					// Check if the file was created and has content
					pgsFilePath := filepath.Join(outDir, tempPgsFile)
					fileInfo, statErr := os.Stat(pgsFilePath)
					if statErr != nil {
						fyne.Do(func() {
							result.SetText(result.Text + "\nCannot find extracted file: " + statErr.Error())
						})
						err = statErr
					} else if fileInfo.Size() == 0 {
						fyne.Do(func() {
							result.SetText(result.Text + "\nExtracted file is empty (0 bytes)")
						})
						err = fmt.Errorf("extracted file is empty (0 bytes)")
					} else {
						fyne.Do(func() {
							result.SetText(result.Text + fmt.Sprintf("\nSuccessfully extracted PGS file (%d bytes)", fileInfo.Size()))
						})
					}
					
					if err == nil {
						// Debug point after successful extraction
						fyne.Do(func() {
							result.SetText(result.Text + "\n\n[DEBUG] PGS extraction completed successfully, starting conversion process")
						})
						
						// Use the user's custom pgs-to-srt-2 tool with Deno
						pgsToSrtScript := "/Users/venimk/Downloads/pgs-to-srt-2/pgs-to-srt.js"
						tessDataPath := "/Users/venimk/Downloads/pgs-to-srt-2/tessdata_fast/eng.traineddata"
						
						// Get absolute paths for input and output
						absInputPath := filepath.Join(outDir, tempPgsFile)
						absOutputPath := filepath.Join(outDir, outFile)
						
						// Check if the script exists
						fyne.Do(func() {
							result.SetText(result.Text + fmt.Sprintf("\n\n[DEBUG] Checking if script exists at: %s", pgsToSrtScript))
						})
						
						if _, statErr := os.Stat(pgsToSrtScript); statErr != nil {
							fyne.Do(func() {
								result.SetText(result.Text + fmt.Sprintf("\n[DEBUG] Script NOT found: %v", statErr))
							})
							return
						}
						
						fyne.Do(func() {
							result.SetText(result.Text + "\n[DEBUG] Script found!")
						})
						
						// Test if Deno is working correctly
						fyne.Do(func() {
							result.SetText(result.Text + "\n[DEBUG] Running Deno version test...")
						})
						testCmd := exec.Command("deno", "--version")
						testOutput, testErr := testCmd.CombinedOutput()
						fyne.Do(func() {
							result.SetText(result.Text + "\n\n=== Deno Version Test ===\n")
							if testErr != nil {
								result.SetText(result.Text + fmt.Sprintf("Deno test error: %v\n", testErr))
							} else {
								result.SetText(result.Text + fmt.Sprintf("Deno version: %s\n", string(testOutput)))
							}
						})
						
						// Show detailed file information
						fyne.Do(func() {
							result.SetText(result.Text + fmt.Sprintf("\nInput SUP file: %s\n", absInputPath))
							result.SetText(result.Text + fmt.Sprintf("Output SRT file: %s\n", absOutputPath))
							result.SetText(result.Text + fmt.Sprintf("Tessdata file: %s\n", tessDataPath))
							
							// Check if input file exists and show size
							if fileInfo, err := os.Stat(absInputPath); err == nil {
								result.SetText(result.Text + fmt.Sprintf("Input file size: %d bytes\n", fileInfo.Size()))
							} else {
								result.SetText(result.Text + fmt.Sprintf("Input file check error: %v\n", err))
							}
						})
						
						// Build and show the command - the script expects input file and output file only
						cmdStr := fmt.Sprintf("deno run --allow-read --allow-write \"%s\" \"%s\" \"%s\"", pgsToSrtScript, absInputPath, absOutputPath)
						fyne.Do(func() {
							result.SetText(result.Text + "\n\n=== Executing Command ===\n" + cmdStr + "\n")
							result.SetText(result.Text + "\nConversion started at: " + time.Now().Format("15:04:05") + "\n")
						})
						
						// Run the conversion tool with Deno - correct argument format
						cmd = exec.Command("deno", "run", "--allow-read", "--allow-write", pgsToSrtScript, absInputPath, absOutputPath)
						output, err = cmd.CombinedOutput()
						
						// Show output
						fyne.Do(func() {
							result.SetText(result.Text + "\n\n=== Conversion Results ===\n")
							result.SetText(result.Text + "Completed at: " + time.Now().Format("15:04:05") + "\n")
							
							// Show truncated output if it's too long
							outputStr := string(output)
							if len(outputStr) > 500 {
								result.SetText(result.Text + "Output (truncated): \n" + outputStr[:500] + "...\n")
							} else {
								result.SetText(result.Text + "Output: \n" + outputStr + "\n")
							}
							
							if err != nil {
								result.SetText(result.Text + "\n❌ Error: " + err.Error() + "\n")
							}
						})
						
						// Check current directory for debugging
						currentDir, _ := os.Getwd()
						fyne.Do(func() {
							result.SetText(result.Text + "\n\n=== Path Debugging ===\n")
							result.SetText(result.Text + fmt.Sprintf("Current working directory: %s\n", currentDir))
							result.SetText(result.Text + fmt.Sprintf("Looking for output file at: %s\n", absOutputPath))
						})
						
						// List files in output directory to see what was created
						files, _ := os.ReadDir(outDir)
						fyne.Do(func() {
							result.SetText(result.Text + fmt.Sprintf("\nFiles in output directory (%s):\n", outDir))
							for _, file := range files {
								result.SetText(result.Text + fmt.Sprintf("- %s\n", file.Name()))
							}
						})
						
						// Check if SRT file was created and show details
						if fileInfo, statErr := os.Stat(absOutputPath); statErr == nil {
							fyne.Do(func() {
								result.SetText(result.Text + "\n✅ SRT file created successfully!")
								result.SetText(result.Text + fmt.Sprintf("\n   - Path: %s", absOutputPath))
								result.SetText(result.Text + fmt.Sprintf("\n   - Size: %d bytes", fileInfo.Size()))
								result.SetText(result.Text + fmt.Sprintf("\n   - Modified: %s", fileInfo.ModTime().Format("15:04:05")))
								
								// Try to count lines in SRT file
								if srtContent, readErr := os.ReadFile(absOutputPath); readErr == nil {
									lines := strings.Split(string(srtContent), "\n")
									result.SetText(result.Text + fmt.Sprintf("\n   - Lines: %d", len(lines)))
									
									// Count subtitle entries (every 4 lines is typically one subtitle)
									subtitleCount := (len(lines) + 3) / 4 // rough estimate
									result.SetText(result.Text + fmt.Sprintf("\n   - Estimated subtitles: ~%d", subtitleCount))
								}
							})
						} else {
							err = fmt.Errorf("SRT file was not created: %v", statErr)
							fyne.Do(func() {
								result.SetText(result.Text + "\n❌ Error: " + err.Error())
							})
						}
					} else {
						// Normal extraction without conversion
						// Use proper file extension based on codec
						var fileExt string
						if t.Codec == "hdmv_pgs_subtitle" || t.Codec == "HDMV PGS" {
							fileExt = "sup"
						} else if t.Codec == "subrip" || t.Codec == "SubRip" {
							fileExt = "srt"
						} else if t.Codec == "ass" || t.Codec == "ssa" || t.Codec == "ASS" || t.Codec == "SSA" {
							fileExt = "ass"
						} else if t.Codec == "vobsub" || t.Codec == "VobSub" {
							fileExt = "idx"
						} else {
							// Use lowercase codec name as fallback
							fileExt = strings.ToLower(t.Codec)
						}
						
						outFile = fmt.Sprintf("%s.track%d_%s.%s", mkvBaseName, t.Num, t.Lang, fileExt)
						cmd := exec.Command("mkvextract", "tracks", mkvPath, fmt.Sprintf("%d:%s", t.Num, outFile))
						cmd.Dir = outDir
						output, err = cmd.CombinedOutput()
					}
				
					// Update UI on main thread
					fyne.Do(func() {
						if err != nil {
							t.State = "Error"
							t.Status.SetText(fmt.Sprintf("[!] Track %d: %s (%s) %s - Error", t.Num, t.Lang, t.Codec, t.Name))
							result.SetText(string(output) + "\nExtraction failed: " + err.Error())
						} else {
							t.State = "Done"
							t.Status.SetText(fmt.Sprintf("[✓] Track %d: %s (%s) %s - Done", t.Num, t.Lang, t.Codec, t.Name))
							progress.SetValue(float64(tracksDone + 1))
						}
						
						// Update track list
						trackList.Objects = nil
						for _, tt := range trackItems {
							trackInfo := widget.NewLabel(fmt.Sprintf("Track %d: %s (%s) %s", tt.Num, tt.Lang, tt.Codec, tt.Name))
							
							if tt.ConvertOCR != nil {
								// For PGS subtitles, show OCR option
								ocrLabel := widget.NewLabel("Convert to SRT")
								row := container.NewHBox(tt.Check, tt.Status, trackInfo, tt.ConvertOCR, ocrLabel)
								trackList.Add(row)
							} else {
								// For other subtitle formats
								row := container.NewHBox(tt.Check, tt.Status, trackInfo)
								trackList.Add(row)
							}
						}
						trackList.Refresh()
					})
				
						tracksDone++
				}
				
				// Final UI update on main thread
				fyne.Do(func() {
					currentTrackLabel.SetText("")
					if tracksDone == len(selected) {
						result.SetText("Extraction complete!")
						progress.SetValue(progress.Max)
					} else {
						result.SetText(fmt.Sprintf("Extraction stopped after %d of %d tracks", tracksDone, len(selected)))
					}
				})
			}()
		})

	// Create button row for better layout
	buttonRow := container.NewHBox(loadTracksBtn, startExtractBtn)

	w.SetContent(container.NewVBox(
		widget.NewLabel("GMM MKV Subtitles Extract (Fyne)"),
		fileBtn,
		selectedFile,
		dirBtn,
		selectedDir,
		buttonRow,
		currentTrackLabel,
		progress,
		widget.NewLabel("Subtitle Tracks:"),
		trackList,
		widget.NewLabel("Results:"),
		result,
	))

	w.ShowAndRun()
}
