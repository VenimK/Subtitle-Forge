package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
	
	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/widget"
)

// TrackItem represents a subtitle track with UI elements
type TrackItem struct {
	Num        int
	Lang       string
	Codec      string
	Name       string
	State      string
	Check      *widget.Check
	Status     *widget.Label
	ConvertOCR *widget.Check // Option to convert PGS to SRT using OCR
}

func main() {
	trackList := container.NewVBox()
	a := app.NewWithID("com.gmm.mkvsubsextract")
	w := a.NewWindow("GMM MKV Subtitles Extract (Fyne)")
	w.Resize(fyne.NewSize(520, 340))

	selectedFile := widget.NewLabel("No MKV file selected.")
	selectedDir := widget.NewLabel("No output directory selected.")
	result := widget.NewMultiLineEntry()
	result.SetPlaceHolder("Extraction results will appear here.")

	progress := widget.NewProgressBar()
	progress.Min = 0
	progress.Max = 1
	progress.SetValue(0)

	currentTrackLabel := widget.NewLabel("")
	trackItems := []*TrackItem{}

	var mkvPath string
	var outDir string

	// Button to select MKV file
	fileBtn := widget.NewButton("Select MKV File", func() {
		dialog.ShowFileOpen(func(file fyne.URIReadCloser, err error) {
			if err != nil || file == nil {
				return
			}
			mkvPath = file.URI().Path()
			selectedFile.SetText(mkvPath)
			
			// Clear previous tracks
			trackItems = []*TrackItem{}
			trackList.Objects = nil
			trackList.Refresh()
			
			result.SetText("File selected. Click 'Load Tracks' to analyze the MKV file.")
		}, w)
	})

	// Button to select output directory
	dirBtn := widget.NewButton("Select Output Directory", func() {
		dialog.ShowFolderOpen(func(list fyne.ListableURI, err error) {
			if err != nil || list == nil {
				return
			}
			outDir = list.Path()
			selectedDir.SetText(outDir)
		}, w)
	})

	// Button to load tracks from MKV file
	loadTracksBtn := widget.NewButton("Load Tracks", func() {
		if mkvPath == "" {
			dialog.ShowError(fmt.Errorf("Please select an MKV file first."), w)
			return
		}
		
		// Run mkvmerge to get track info
		cmd := exec.Command("mkvmerge", "-J", mkvPath)
		output, err := cmd.Output()
		if err != nil {
			dialog.ShowError(fmt.Errorf("Error running mkvmerge: %v", err), w)
			return
		}
		
		// Parse JSON output
		var mkvInfo map[string]interface{}
		err = json.Unmarshal(output, &mkvInfo)
		if err != nil {
			dialog.ShowError(fmt.Errorf("Error parsing mkvmerge output: %v", err), w)
			return
		}
		
		// Extract tracks
		tracks, ok := mkvInfo["tracks"].([]interface{})
		if !ok {
			dialog.ShowError(fmt.Errorf("No tracks found in MKV file."), w)
			return
		}
		
		// Clear previous tracks
		trackItems = []*TrackItem{}
		trackList.Objects = nil
		
		// Process subtitle tracks
		for _, track := range tracks {
			trackMap, ok := track.(map[string]interface{})
			if !ok {
				continue
			}
			
			// Check if this is a subtitle track
			trackType, ok := trackMap["type"].(string)
			if !ok || trackType != "subtitles" {
				continue
			}
			
			// Get track properties
			properties, ok := trackMap["properties"].(map[string]interface{})
			if !ok {
				continue
			}
			
			trackID := int(trackMap["id"].(float64))
			trackLang := properties["language"].(string)
			trackCodec := trackMap["codec"].(string)
			
			// Get track name if available
			var trackName string
			if name, ok := properties["track_name"].(string); ok {
				trackName = name
			} else {
				trackName = ""
			}
			
			// Create UI elements for this track
			check := widget.NewCheck("", nil)
			check.SetChecked(true)
			status := widget.NewLabel("[ ]")
			
			// Create track item
			t := &TrackItem{
				Num:    trackID,
				Lang:   trackLang,
				Codec:  trackCodec,
				Name:   trackName,
				State:  "Pending",
				Check:  check,
				Status: status,
			}
			
			// Add OCR option for PGS subtitles
			if trackCodec == "hdmv_pgs_subtitle" || trackCodec == "HDMV PGS" {
				t.ConvertOCR = widget.NewCheck("", nil)
				t.ConvertOCR.SetChecked(true)
			}
			
			trackItems = append(trackItems, t)
			
			// Create row for this track
			trackInfo := widget.NewLabel(fmt.Sprintf("Track %d: %s (%s) %s", trackID, trackLang, trackCodec, trackName))
			
			var row *fyne.Container
			if t.ConvertOCR != nil {
				// For PGS subtitles, show OCR option
				ocrLabel := widget.NewLabel("Convert to SRT")
				row = container.NewHBox(check, status, trackInfo, t.ConvertOCR, ocrLabel)
			} else {
				// For other subtitle formats
				row = container.NewHBox(check, status, trackInfo)
			}
			
			trackList.Add(row)
		}
		trackList.Refresh()
		
		result.SetText("Tracks loaded. Select the tracks you want to extract, then click 'Start Extraction'")
	})

	// Button to start extraction of selected tracks
	startExtractBtn := widget.NewButton("Start Extraction", func() {
		if mkvPath == "" || outDir == "" {
			dialog.ShowError(fmt.Errorf("Please select both MKV file and output directory."), w)
			return
		}
		
		go func() {
			selected := []*TrackItem{}
			for _, t := range trackItems {
				if t.Check.Checked {
					selected = append(selected, t)
				}
			}
			if len(selected) == 0 {
				// Thread-safe UI update
				fyne.CurrentApp().SendNotification(&fyne.Notification{
					Title:   "No Tracks",
					Content: "No tracks selected.",
				})
				return
			}
			
			// Set up progress bar
			fyne.Do(func() {
				result.SetText("Extracting selected tracks...")
				progress.Max = float64(len(selected))
				progress.SetValue(0)
			})
			
			tracksDone := 0
			var output []byte
			var err error
			
			for i, t := range selected {
				// Update UI on main thread
				fyne.Do(func() {
					currentTrackLabel.SetText(fmt.Sprintf("Extracting track %d of %d: %s (%s) %s", i+1, len(selected), t.Lang, t.Codec, t.Name))
				})
				
				// Extract the subtitle track
				var outFile string
				
				// Get base filename without extension
				mkvBaseName := filepath.Base(mkvPath)
				mkvBaseName = strings.TrimSuffix(mkvBaseName, filepath.Ext(mkvBaseName))
				
				// Check if this is a PGS track with OCR conversion requested
				if t.ConvertOCR != nil && t.ConvertOCR.Checked && (t.Codec == "hdmv_pgs_subtitle" || t.Codec == "HDMV PGS") {
					// First extract as PGS
					fyne.Do(func() {
						result.SetText(result.Text + "\n\n[DEBUG] Starting PGS extraction process")
					})
					tempPgsFile := fmt.Sprintf("%s.track%d_%s.sup", mkvBaseName, t.Num, t.Lang)
					outFile = fmt.Sprintf("%s.track%d_%s.srt", mkvBaseName, t.Num, t.Lang) // Final output will be SRT
					
					// Get absolute paths for extraction
					absPgsPath := filepath.Join(outDir, tempPgsFile)
					
					// Debug output
					fyne.Do(func() {
						currentTrackLabel.SetText(fmt.Sprintf("Extracting PGS track %d...", t.Num))
						result.SetText(result.Text + "\n\n=== PGS Extraction ===\n")
						result.SetText(result.Text + fmt.Sprintf("Track: %d (%s)\n", t.Num, t.Lang))
						result.SetText(result.Text + fmt.Sprintf("Output directory: %s\n", outDir))
						result.SetText(result.Text + fmt.Sprintf("PGS file: %s\n", tempPgsFile))
						result.SetText(result.Text + fmt.Sprintf("Absolute path: %s\n", absPgsPath))
					})
					
					// Extract PGS first - use full command for debugging
					cmdStr := fmt.Sprintf("mkvextract tracks \"%s\" %d:\"%s\"", mkvPath, t.Num, tempPgsFile)
					fyne.Do(func() {
						result.SetText(result.Text + "\nRunning: " + cmdStr)
					})
					
					// Create the command with proper arguments
					cmd := exec.Command("mkvextract", "tracks", mkvPath, fmt.Sprintf("%d:%s", t.Num, tempPgsFile))
					cmd.Dir = outDir
					
					// Run the command and capture output
					output, err = cmd.CombinedOutput()
					
					// Debug output - show command result
					fyne.Do(func() {
						result.SetText(result.Text + "\nCommand output: " + string(output))
						if err != nil {
							result.SetText(result.Text + "\nError: " + err.Error())
						}
					})
					
					// Check if the file was created and has content
					pgsFilePath := filepath.Join(outDir, tempPgsFile)
					fileInfo, statErr := os.Stat(pgsFilePath)
					if statErr != nil {
						fyne.Do(func() {
							result.SetText(result.Text + "\nCannot find extracted file: " + statErr.Error())
						})
						err = statErr
					} else if fileInfo.Size() == 0 {
						fyne.Do(func() {
							result.SetText(result.Text + "\nExtracted file is empty (0 bytes)")
						})
						err = fmt.Errorf("extracted file is empty (0 bytes)")
					} else {
						fyne.Do(func() {
							result.SetText(result.Text + fmt.Sprintf("\nSuccessfully extracted PGS file (%d bytes)", fileInfo.Size()))
						})
					}
					
					if err == nil {
						// Debug point after successful extraction
						fyne.Do(func() {
							result.SetText(result.Text + "\n\n[DEBUG] PGS extraction completed successfully, starting conversion process")
						})
						
						// Use the user's custom pgs-to-srt-2 tool with Deno
						pgsToSrtScript := "/Users/venimk/Downloads/pgs-to-srt-2/pgs-to-srt.js"
						tessDataPath := "/Users/venimk/Downloads/pgs-to-srt-2/tessdata_fast/eng.traineddata"
						
						// Get absolute paths for input and output
						absInputPath := filepath.Join(outDir, tempPgsFile)
						absOutputPath := filepath.Join(outDir, outFile)
						
						// Check if the script exists
						fyne.Do(func() {
							result.SetText(result.Text + fmt.Sprintf("\n\n[DEBUG] Checking if script exists at: %s", pgsToSrtScript))
						})
						
						if _, statErr := os.Stat(pgsToSrtScript); statErr != nil {
							fyne.Do(func() {
								result.SetText(result.Text + fmt.Sprintf("\n[DEBUG] Script NOT found: %v", statErr))
							})
							return
						}
						
						fyne.Do(func() {
							result.SetText(result.Text + "\n[DEBUG] Script found!")
						})
						
						// Test if Deno is working correctly
						fyne.Do(func() {
							result.SetText(result.Text + "\n[DEBUG] Running Deno version test...")
						})
						testCmd := exec.Command("deno", "--version")
						testOutput, testErr := testCmd.CombinedOutput()
						fyne.Do(func() {
							result.SetText(result.Text + "\n\n=== Deno Version Test ===\n")
							if testErr != nil {
								result.SetText(result.Text + fmt.Sprintf("Deno test error: %v\n", testErr))
							} else {
								result.SetText(result.Text + fmt.Sprintf("Deno version: %s\n", string(testOutput)))
							}
						})
						
						// Show detailed file information
						fyne.Do(func() {
							result.SetText(result.Text + fmt.Sprintf("\nInput SUP file: %s\n", absInputPath))
							result.SetText(result.Text + fmt.Sprintf("Output SRT file: %s\n", absOutputPath))
							result.SetText(result.Text + fmt.Sprintf("Tessdata file: %s\n", tessDataPath))
							
							// Check if input file exists and show size
							if fileInfo, err := os.Stat(absInputPath); err == nil {
								result.SetText(result.Text + fmt.Sprintf("Input file size: %d bytes\n", fileInfo.Size()))
							} else {
								result.SetText(result.Text + fmt.Sprintf("Input file check error: %v\n", err))
							}
						})
						
						// Build and show the command - the script expects input file and output file only
						cmdStr := fmt.Sprintf("deno run --allow-read --allow-write \"%s\" \"%s\" \"%s\"", pgsToSrtScript, absInputPath, absOutputPath)
						fyne.Do(func() {
							result.SetText(result.Text + "\n\n=== Executing Command ===\n" + cmdStr + "\n")
							result.SetText(result.Text + "\nConversion started at: " + time.Now().Format("15:04:05") + "\n")
						})
						
						// Run the conversion tool with Deno - correct argument format
						cmd = exec.Command("deno", "run", "--allow-read", "--allow-write", pgsToSrtScript, absInputPath, absOutputPath)
						output, err = cmd.CombinedOutput()
						
						// Show output
						fyne.Do(func() {
							result.SetText(result.Text + "\n\n=== Conversion Results ===\n")
							result.SetText(result.Text + "Completed at: " + time.Now().Format("15:04:05") + "\n")
							
							// Show truncated output if it's too long
							outputStr := string(output)
							if len(outputStr) > 500 {
								result.SetText(result.Text + "Output (truncated): \n" + outputStr[:500] + "...\n")
							} else {
								result.SetText(result.Text + "Output: \n" + outputStr + "\n")
							}
							
							if err != nil {
								result.SetText(result.Text + "\n❌ Error: " + err.Error() + "\n")
							}
						})
						
						// Check current directory for debugging
						currentDir, _ := os.Getwd()
						fyne.Do(func() {
							result.SetText(result.Text + "\n\n=== Path Debugging ===\n")
							result.SetText(result.Text + fmt.Sprintf("Current working directory: %s\n", currentDir))
							result.SetText(result.Text + fmt.Sprintf("Looking for output file at: %s\n", absOutputPath))
						})
						
						// List files in output directory to see what was created
						files, _ := os.ReadDir(outDir)
						fyne.Do(func() {
							result.SetText(result.Text + fmt.Sprintf("\nFiles in output directory (%s):\n", outDir))
							for _, file := range files {
								result.SetText(result.Text + fmt.Sprintf("- %s\n", file.Name()))
							}
						})
						
						// Check if SRT file was created and show details
						if fileInfo, statErr := os.Stat(absOutputPath); statErr == nil {
							fyne.Do(func() {
								result.SetText(result.Text + "\n✅ SRT file created successfully!")
								result.SetText(result.Text + fmt.Sprintf("\n   - Path: %s", absOutputPath))
								result.SetText(result.Text + fmt.Sprintf("\n   - Size: %d bytes", fileInfo.Size()))
								result.SetText(result.Text + fmt.Sprintf("\n   - Modified: %s", fileInfo.ModTime().Format("15:04:05")))
								
								// Try to count lines in SRT file
								if srtContent, readErr := os.ReadFile(absOutputPath); readErr == nil {
									lines := strings.Split(string(srtContent), "\n")
									result.SetText(result.Text + fmt.Sprintf("\n   - Lines: %d", len(lines)))
									
									// Count subtitle entries (every 4 lines is typically one subtitle)
									subtitleCount := (len(lines) + 3) / 4 // rough estimate
									result.SetText(result.Text + fmt.Sprintf("\n   - Estimated subtitles: ~%d", subtitleCount))
								}
							})
						} else {
							err = fmt.Errorf("SRT file was not created: %v", statErr)
							fyne.Do(func() {
								result.SetText(result.Text + "\n❌ Error: " + err.Error())
							})
						}
					}
				} else {
					// Normal extraction without conversion
					// Use proper file extension based on codec
					var fileExt string
					if t.Codec == "hdmv_pgs_subtitle" || t.Codec == "HDMV PGS" {
						fileExt = "sup"
					} else if t.Codec == "subrip" || t.Codec == "SubRip" {
						fileExt = "srt"
					} else if t.Codec == "ass" || t.Codec == "ssa" || t.Codec == "ASS" || t.Codec == "SSA" {
						fileExt = "ass"
					} else if t.Codec == "vobsub" || t.Codec == "VobSub" {
						fileExt = "idx"
					} else {
						// Use lowercase codec name as fallback
						fileExt = strings.ToLower(t.Codec)
					}
					
					outFile = fmt.Sprintf("%s.track%d_%s.%s", mkvBaseName, t.Num, t.Lang, fileExt)
					cmd := exec.Command("mkvextract", "tracks", mkvPath, fmt.Sprintf("%d:%s", t.Num, outFile))
					cmd.Dir = outDir
					output, err = cmd.CombinedOutput()
				}
				
				// Update UI on main thread
				fyne.Do(func() {
					if err != nil {
						t.State = "Error"
						t.Status.SetText(fmt.Sprintf("[!] Track %d: %s (%s) %s - Error", t.Num, t.Lang, t.Codec, t.Name))
						result.SetText(string(output) + "\nExtraction failed: " + err.Error())
					} else {
						t.State = "Done"
						t.Status.SetText(fmt.Sprintf("[✓] Track %d: %s (%s) %s - Done", t.Num, t.Lang, t.Codec, t.Name))
						progress.SetValue(float64(tracksDone + 1))
					}
					
					// Update track list
					trackList.Objects = nil
					for _, tt := range trackItems {
						trackInfo := widget.NewLabel(fmt.Sprintf("Track %d: %s (%s) %s", tt.Num, tt.Lang, tt.Codec, tt.Name))
						
						if tt.ConvertOCR != nil {
							// For PGS subtitles, show OCR option
							ocrLabel := widget.NewLabel("Convert to SRT")
							row := container.NewHBox(tt.Check, tt.Status, trackInfo, tt.ConvertOCR, ocrLabel)
							trackList.Add(row)
						} else {
							// For other subtitle formats
							row := container.NewHBox(tt.Check, tt.Status, trackInfo)
							trackList.Add(row)
						}
					}
					trackList.Refresh()
				})
				
				tracksDone++
			}
			
			// Final UI update on main thread
			fyne.Do(func() {
				currentTrackLabel.SetText("")
				if tracksDone == len(selected) {
					result.SetText("Extraction complete!")
					progress.SetValue(progress.Max)
				} else {
					result.SetText(fmt.Sprintf("Extraction stopped after %d of %d tracks", tracksDone, len(selected)))
				}
			})
		}()
	})

	// Create button row for better layout
	buttonRow := container.NewHBox(loadTracksBtn, startExtractBtn)

	w.SetContent(container.NewVBox(
		widget.NewLabel("GMM MKV Subtitles Extract (Fyne)"),
		fileBtn,
		selectedFile,
		dirBtn,
		selectedDir,
		buttonRow,
		currentTrackLabel,
		progress,
		widget.NewLabel("Subtitle Tracks:"),
		trackList,
		widget.NewLabel("Results:"),
		result,
	))

	w.ShowAndRun()
}
