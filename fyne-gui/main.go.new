package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
	
	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/widget"
)

// TrackItem represents a subtitle track with UI elements
type TrackItem struct {
	Num        int
	Lang       string
	Codec      string
	Name       string
	State      string
	Check      *widget.Check
	Status     *widget.Label
	ConvertOCR *widget.Check // Option to convert PGS to SRT using OCR
}

func main() {
	trackList := container.NewVBox()
	a := app.NewWithID("com.gmm.mkvsubsextract")
	w := a.NewWindow("GMM MKV Subtitles Extract (Fyne)")
	w.Resize(fyne.NewSize(520, 340))

	selectedFile := widget.NewLabel("No MKV file selected.")
	selectedDir := widget.NewLabel("No output directory selected.")
	result := widget.NewMultiLineEntry()
	result.SetPlaceHolder("Extraction results will appear here.")

	progress := widget.NewProgressBar()
	progress.Min = 0
	progress.Max = 1
	progress.SetValue(0)

	currentTrackLabel := widget.NewLabel("")
	trackItems := []*TrackItem{}

	var mkvPath string
	var outDir string


	fileBtn := widget.NewButton("Select MKV File", func() {
		dialog.ShowFileOpen(func(reader fyne.URIReadCloser, err error) {
			if err == nil && reader != nil {
				mkvPath = reader.URI().Path()
				selectedFile.SetText("Selected: " + mkvPath)
			}
		}, w)
	})

dirBtn := widget.NewButton("Select Output Directory", func() {
	dialog.ShowFolderOpen(func(list fyne.ListableURI, err error) {
		if err == nil && list != nil {
			outDir = list.Path()
			selectedDir.SetText("Output: " + outDir)
		}
	}, w)
})

// Button to load and display tracks
loadTracksBtn := widget.NewButton("Load Subtitle Tracks", func() {
	if mkvPath == "" || outDir == "" {
		dialog.ShowError(fmt.Errorf("Please select both MKV file and output directory."), w)
		return
	}
	result.SetText("Loading subtitle tracks...")
	progress.SetValue(0)
	progress.Max = 1
	currentTrackLabel.SetText("")

	// Clear any previous tracks
	trackItems = nil

	// Parse mkvmerge -J to get subtitle tracks
	cmdInfo := exec.Command("mkvmerge", "-J", mkvPath)
	infoOut, err := cmdInfo.Output()
	trackItems = nil
	if err == nil {
		var info struct {
			Tracks []struct {
				Id     int    `json:"id"`
				Type   string `json:"type"`
				Codec  string `json:"codec"`
				Props  struct {
					Language  string `json:"language"`
					TrackName string `json:"track_name"`
				} `json:"properties"`
			} `json:"tracks"`
		}
		if json.Unmarshal(infoOut, &info) == nil {
			for _, t := range info.Tracks {
				if t.Type == "subtitles" {
					item := &TrackItem{
						Num:    t.Id,
						Lang:   t.Props.Language,
						Codec:  t.Codec,
						Name:   t.Props.TrackName,
						State:  "Pending",
						Check:  widget.NewCheck("", nil),
						Status: widget.NewLabel("[ ] Pending"),
						ConvertOCR: widget.NewCheck("", nil),
					}
					
					// Default: none selected
					item.Check.SetChecked(false)
					
					// Only show OCR option for PGS subtitles
					if t.Codec == "hdmv_pgs_subtitle" || t.Codec == "HDMV PGS" {
						item.ConvertOCR.SetChecked(false)
					} else {
						// Hide OCR option for non-PGS subtitles
						item.ConvertOCR = nil
					}
					
					trackItems = append(trackItems, item)
				}
			}
		}
	}
	if len(trackItems) == 0 {
		// fallback: 1 dummy track
		item := &TrackItem{Num: 0, Lang: "?", Codec: "?", Name: "", State: "Pending", Check: widget.NewCheck("", nil), Status: widget.NewLabel("[ ] Pending")}
		item.Check.SetChecked(false)
		trackItems = append(trackItems, item)
	}
	progress.Max = float64(len(trackItems))
	progress.SetValue(0)
	for _, t := range trackItems {
		t.State = "Pending"
		t.Status.SetText("[ ] Pending")
	}

	// update the UI list
	trackList.Objects = nil
	for _, t := range trackItems {
		trackInfo := widget.NewLabel(fmt.Sprintf("Track %d: %s (%s) %s", t.Num, t.Lang, t.Codec, t.Name))
		
		if t.ConvertOCR != nil {
			// For PGS subtitles, show OCR option
			ocrLabel := widget.NewLabel("Convert to SRT")
			row := container.NewHBox(t.Check, t.Status, trackInfo, t.ConvertOCR, ocrLabel)
			trackList.Add(row)
		} else {
			// For other subtitle formats
			row := container.NewHBox(t.Check, t.Status, trackInfo)
			trackList.Add(row)
		}
	}
	trackList.Refresh()

	result.SetText("Tracks loaded. Select the tracks you want to extract, then click 'Start Extraction'")
})

// Button to start extraction of selected tracks
